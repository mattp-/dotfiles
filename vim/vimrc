set nocompatible
filetype off
set rtp+=~/.vim/bundle/vundle
"uuuu
call vundle#rc()

Bundle 'gmarik/vundle'

" Generally Useful:
Bundle 'kien/ctrlp.vim'
Bundle 'scrooloose/nerdtree'
Bundle 'vim-scripts/IndexedSearch'
Bundle 'bronson/vim-trailing-whitespace'
Bundle 'Raimondi/YAIFA'
Bundle 'scrooloose/nerdcommenter'
Bundle 'tpope/vim-surround'
Bundle 'edsono/vim-matchit'
Bundle 'scrooloose/syntastic'
Bundle 'majutsushi/tagbar'
Bundle 'vim-scripts/Zenburn'
Bundle 'tpope/vim-endwise'
Bundle 'vim-scripts/Align'
Bundle 'tpope/vim-repeat'
Bundle 'tpope/vim-fugitive'
Bundle 'tpope/vim-git'
Bundle 'vim-scripts/jQuery'
Bundle 'tomasr/molokai'
Bundle 'tpope/vim-rails'
Bundle 'tpope/vim-vividchalk'
"Bundle 'Shougo/neocomplcache'
Bundle 'tpope/vim-speeddating'
Bundle 'c9s/perlomni.vim'
Bundle 'ervandew/supertab'

" Bundle: git://git.wincent.com/command-t.git
" #   If rvm is installed, make sure we compile command-t with the system ruby
" Bundle-Command: if which rvm >/dev/null 2>&1; then rvm system exec rake make; else rake make; fi

" Programming:
" # Bundle: git://github.com/vim-scripts/taglist.vim
" # Bundle: git://github.com/msanders/snipmate.vim.git
" # Bundle: git://github.com/scrooloose/snipmate-snippets.git
" # Bundle: git://github.com/tpope/vim-markdown.git
" # Bundle: git://github.com/timcharper/textile.vim.git
" # Bundle: git://github.com/kchmck/vim-coffee-script.git

" Ruby/Rails Programming:
" Bundle: git://github.com/vim-ruby/vim-ruby.git
" Bundle: git://github.com/tpope/vim-rake.git
" # Bundle: git://github.com/janx/vim-rubytest.git
" Bundle: git://github.com/tsaleh/vim-shoulda.git
" Bundle: git://github.com/tpope/vim-cucumber.git
" Bundle: git://github.com/tpope/vim-haml.git
" # Bundle: git://github.com/astashov/vim-ruby-debugger.git

" Custom
" ! Bundle: git://github.com/vim-scripts/perl-support.vim.git
" ! Bundle: git://github.com/wookiehangover/jshint.vim.git
" ! Bundle: git://github.com/fholgado/minibufexpl.vim.git

" Config
set t_Co=256
set term=screen-256color
syntax on
filetype on
filetype plugin on
set vb
set incsearch
set showmatch

" tabs - defaults loaded by YAIFA
set smarttab
set expandtab

" indents
set smartindent
set autoindent

set number
set nobackup

set clipboard+=unnamed

set nolist
"set list
set lcs=tab:>-,trail:-

" case
set ignorecase
set infercase
set smartcase

set backspace=indent,eol,start
set hidden

" binds
" Tidy selected lines (or entire file) with _t:
nnoremap <silent> = :%!perltidy -q<Enter>
vnoremap <silent> = :!perltidy -q<Enter>
set pastetoggle=<F11>


" Indent using tabs (while in visual mode)
vnoremap < <gv
vnoremap > >gv
" make tab in v mode ident code
vmap <tab> >gv
vmap <s-tab> <gv
" make tab in normal mode ident code
nmap <tab> I<tab><esc>
nmap <s-tab> ^i<bs><esc>

" Search only in the selected block (visual mode)
vnoremap / <esc>/\%V

" Buffer horizontal traversal using C-j and C-k
nnoremap <C-j> <C-w>j
nnoremap <C-k> <C-w>k

" Tabs uses c-l and c-h
map <C-h> <esc>:tabprevious<cr>
map <C-l> <esc>:tabnext<cr>

" simple stuff
let mapleader = ","
map <Leader>t :CtrlP<Return>
map <Leader>b :CtrlPMRU<Return>
map <Leader>a :bprev<Return>
map <Leader>s :bnext<Return>
map <Leader>d :call Bclose()<Return>
map <Leader>f :b
"nnoremap <silent> <Leader>p :TlistToggle<CR>
nnoremap <silent> <Leader>p :TagbarToggle<CR>
"
"autocmd VimEnter * nested :call tagbar#autoopen(1)
"autocmd BufEnter * nested :call tagbar#autoopen(1)
"autocmd FileType * nested :call tagbar#autoopen(0)

nmap <silent> <Leader>n :NERDTreeToggle<CR>
nnoremap <silent> <Leader>c <Plug>RubyTestRun
nnoremap <silent> <Leader>C <Plug>RubyFileRun
nnoremap <silent> <Leader>l <Plug>RubyTestRunLast

map <Leader>f :LustyFilesystemExplorer<Return>
map <Leader>r :LustyFilesystemExplorerFromHere<Return>
"map <Leader>b :LustyBufferExplorer<Return>
"map <Leader>j :LustyJuggler<Return>
map <Leader><tab> :bNext<Return>
map <Leader><S-tab> :LustyJugglePrevious<Return>
map <Leader>q :bNext<Return>
map <Leader>g :LustyBufferGrep<Return>

"tlist stuff
"let Tlist_Auto_Open = 1
"let Tlist_Show_One_File = 1
"let Tlist_Exit_OnlyWindow = 1

" perl stuff
let perl_include_pod = 1
let perl_extended_vars = 1
set isk+=:

colorscheme zenburn
" colorscheme molokai
set wildignore+=*.o,*.obj,.git,*.png,*.jpg,.*gif
set encoding=utf8
set cul

" Syntastic
set matchpairs=(:),{:},[:],<:>
let g:syntastic_enable_signs=1
let g:syntastic_auto_loc_list=1
let g:syntastic_quiet_warnings=1

let g:CommandTMatchWindowReverse=1
set statusline+=%#warningmsg#
set statusline+=%{SyntasticStatuslineFlag()}
set statusline+=%*

vmap <leader>c <esc>:'<,'>:CoffeeCompile<CR>
map <leader>c :CoffeeCompile<CR>

nnoremap j gj
nnoremap k gk

noremap <C-h> <C-w>h
noremap <C-j> <C-w>j
noremap <C-k> <C-w>k
noremap <C-l> <C-w>l

set mouse=a

" omake from vim!
"set shell=/bin/bash\ -i
"map <Leader>o :!omake &<cr>

" Bclose() {{{2
" delete buffer without closing window
function! Bclose()
    let curbufnr = bufnr("%")
    let altbufnr = bufnr("#")

    if buflisted(altbufnr)
        buffer #
    else
        bnext
    endif

    if bufnr("%") == curbufnr
        new
    endif

    if buflisted(curbufnr)
        execute("bdelete! " . curbufnr)
    endif
endfunction
cabbrev bdelete call Bclose()

"" Use neocomplcache.
"let g:neocomplcache_enable_at_startup = 1
"" Use smartcase.
"let g:neocomplcache_enable_smart_case = 1
"" Use camel case completion.
"let g:neocomplcache_enable_camel_case_completion = 1
"" Use underbar completion.
"let g:neocomplcache_enable_underbar_completion = 1
"" Set minimum syntax keyword length.
"let g:neocomplcache_min_syntax_length = 3
"let g:neocomplcache_lock_buffer_name_pattern = '\*ku\*'

"" Define keyword.
"if !exists('g:neocomplcache_keyword_patterns')
  "let g:neocomplcache_keyword_patterns = {}
"endif
"let g:neocomplcache_keyword_patterns['default'] = '\h\w*'

"" Plugin key-mappings.
"imap <C-k> <Plug>(neocomplcache_snippets_expand)
"smap <C-k> <Plug>(neocomplcache_snippets_expand)
"inoremap <expr><C-g> neocomplcache#undo_completion()
"inoremap <expr><C-l> neocomplcache#complete_common_string()

"" Recommended key-mappings.
"" <CR>: close popup and save indent.
"inoremap <expr><CR> neocomplcache#smart_close_popup().<CR>
"" <TAB>: completion.
"inoremap <expr><TAB> pumvisible() ? "\<C-n>" : "\<TAB>"
"" <C-h>, <BS>: close popup and delete backword char.
"inoremap <expr><C-h> neocomplcache#smart_close_popup()."\<C-h>"
"inoremap <expr><BS> neocomplcache#smart_close_popup()."\<C-h>"
"inoremap <expr><C-y> neocomplcache#close_popup()
"inoremap <expr><C-e> neocomplcache#cancel_popup()

"" AutoComplPop like behavior.
""let g:neocomplcache_enable_auto_select = 1

"" Shell like behavior(not recommended).
""set completeopt+=longest
""let g:neocomplcache_enable_auto_select = 1
""let g:neocomplcache_disable_auto_complete = 1
""inoremap <expr><TAB>  pumvisible() ? "\<Down>" : "\<TAB>"
""inoremap <expr><CR>  neocomplcache#smart_close_popup() . "\<CR>"

"" Enable omni completion.
"autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
"autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
"autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
"autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
"autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags

"" Enable heavy omni completion.
"if !exists('g:neocomplcache_omni_patterns')
  "let g:neocomplcache_omni_patterns = {}
"endif
